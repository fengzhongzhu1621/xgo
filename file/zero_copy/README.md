# 零拷贝
零拷贝（Zero-Copy）是一种优化数据传输的技术，其核心目标是减少数据在用户空间和内核空间之间的复制。
在传统的 I/O 操作中，数据通常需要从内核缓冲区复制到用户空间缓冲区，再从用户空间缓冲区复制到目标位置（如网络套接字）。
零拷贝技术通过特定的系统调用，直接在内核空间内完成数据传输，从而提升性能。
比如 Linux 的 sendfile 系统调用。这种机制让数据在内核空间里直接流动，用户空间几乎不用插手。
零拷贝在高并发下很省 CPU，但多个 goroutine 同时操作文件或连接时，记得加锁或用通道协调。

# 接口
* io.ReaderFrom：实现这个接口的类型能直接从 io.Reader 读取数据。
* io.WriterTo：实现这个接口的类型能直接把数据写入 io.Writer。

# sendfile
* 功能：sendfile 是一个高效的系统调用，允许将文件内容直接传输到网络套接字，避免用户空间的介入。
* 底层实现：它利用了内核的文件缓存和网络栈，直接将数据从文件描述符传输到套接字描述符。
* 使用场景：非常适合静态文件传输，例如 Web 服务器（如 Nginx）发送 HTML 文件。
* 限制：源必须是文件描述符，目标必须是套接字描述符，且不支持复杂的处理逻辑。

# splice
* 功能：splice 允许在两个文件描述符之间移动数据，无需用户空间缓冲区。
* 底层实现：它通过管道（pipe）或类似的内核机制，在内核空间内完成数据重定向。
* 使用场景：适用于网络数据到文件、文件到网络等场景，比 sendfile 更灵活。
* 限制：需要至少一个文件描述符是管道，且在某些平台上的支持有限。

# mmap
* 功能：mmap将文件映射到进程的虚拟内存空间，程序可以像访问内存一样访问文件内容。
* 底层实现：通过页面映射，内核将文件数据映射到用户空间的内存地址。
* 使用场景：适合需要随机访问文件内容的场景，例如数据库引擎。
* 限制：虽然减少了显式读取，但数据仍需从内核缓冲区复制到映射区域，不完全是“零拷贝”。

