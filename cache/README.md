# Go 缓存库对比：fastcache vs bigcache vs go-cache vs ristretto

| **对比维度**       | **fastcache**                          | **bigcache**                          | **go-cache**                          | **ristretto**                         |
|--------------------|----------------------------------------|----------------------------------------|----------------------------------------|----------------------------------------|
| **设计目标**       | 极致性能、低 GC 压力，适合高并发读多写少 | 超大规模缓存（TB 级别），高并发读写混合 | 简单易用的通用缓存，支持 TTL           | 高性能、低内存占用的通用缓存           |
| **内存管理**       | 预分配内存池，完全绕过 GC              | 分片（Sharding）管理，支持动态调整      | 使用 Go 的 `map` + 定时清理            | 基于分片和 LRU 的内存优化              |
| **并发性能**       | 读无锁（原子操作），写单锁（可能瓶颈）   | 分片独立加锁，读写并行，锁竞争低        | 全局锁（并发性能较低）                 | 分片设计，读写并行，锁竞争低           |
| **功能特性**       | 基础 API（Set/Get/Delete），无 TTL      | 支持 TTL、自动清理、统计信息、持久化    | 支持 TTL、自定义过期策略               | 支持 TTL、LRU 淘汰、统计信息           |
| **缓存大小**       | 初始化时固定，不可动态扩展              | 可调整分片数量，适应数据增长            | 无限制（依赖内存）                     | 可配置最大内存限制                     |
| **适用场景**       | 高并发读多写少（API 网关、实时计算）    | 大容量缓存（TB 级别）、高并发读写混合   | 简单缓存、开发测试、短期数据存储       | 高性能通用缓存（Web 服务、微服务）     |
| **性能特点**       | 读性能极高（接近内存访问速度）          | 读写均衡，分片设计稳定高并发            | 并发性能较低（全局锁）                 | 读写均衡，内存占用低                   |
| **额外功能**       | 无                                      | 统计信息、过期策略、持久化支持          | 自定义过期策略、简单易用               | LRU 淘汰、统计信息、内存优化           |
| **GC 影响**        | 无 GC 压力（预分配内存）                | 低 GC 压力（分片管理）                  | 较高 GC 压力（动态 `map`）             | 低 GC 压力（内存池优化）               |
| **依赖**           | 无外部依赖                              | 无外部依赖                              | 无外部依赖                              | 无外部依赖                              |

### **总结选择建议**
| **需求场景**                     | **推荐库**   | **理由**                                                                 |
|----------------------------------|-------------|--------------------------------------------------------------------------|
| 高并发读多写少，追求极致延迟      | **fastcache** | 无 GC 压力，读性能极高，适合 API 网关、实时计算等场景                     |
| 大容量缓存（TB 级别），需要 TTL/统计 | **bigcache**  | 分片管理支持大容量数据，支持 TTL 和持久化                                |
| 简单缓存，开发测试或短期数据存储  | **go-cache**  | 易用性强，支持 TTL，适合快速原型开发或临时缓存                           |
| 高性能通用缓存（Web/微服务）      | **ristretto** | 内存占用低，支持 LRU 淘汰，适合需要平衡性能和内存的场景                  |

### **关键差异总结**
1. **GC 优化**：
    - `fastcache` 和 `ristretto` 通过内存池减少 GC 压力，`bigcache` 分片设计降低 GC 影响，`go-cache` 依赖 Go 的 `map`（GC 压力较高）。
2. **并发模型**：
    - `fastcache` 读无锁但写单锁，`bigcache` 和 `ristretto` 分片设计实现高并发读写。
3. **功能丰富度**：
    - `go-cache` 最简单，`ristretto` 和 `bigcache` 功能最全（TTL、统计、持久化）。
4. **适用规模**：
    - `fastcache` 适合中小规模高并发读，`bigcache` 适合超大规模数据，`ristretto` 适合通用高性能场景。
