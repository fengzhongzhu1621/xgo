# 1. 简介
A high performance memory-bound Go cache

是一个 Go 语言实现的高效、线程安全的LRU（Least Recently Used）缓存。

* 线程安全：在多线程中进行安全的读写。
* LRU 缓存：自动淘汰最少使用的数据项。
* 高效内存管理：使用自定义的 expensive 代价计算和 sharded 哈希表来提供较低的内存开销。
* 支持高并发
* 支持缓存项过期：可以设置最大有效时间，过期后自动移除。

```go
go get github.com/dgraph-io/ristretto/v2
```

# 2. 配置参数
## 2.1 NumCounters
缓存需要使用的计数器数量。较大的计数器数量有助于减少缓存失效的概率，但会增加内存消耗。
当总的资源占用超过maxcost的限制时，会触发淘汰策略，那么如何确定要淘汰哪一个数据呢，
根据TinyLFU算法，会尽可能淘汰被访问次数最少的数据，即不经常用的数据，自然就没有缓存的价值。
如何记录每一个key的被访问次数呢？ 最简单是为每一个数据设置一个计数器（实际情况不是这样，实际用到了Count-Min sketch算法，利用该算法就无需为每一个数据都设置一个计数器，更节省资源）。
需要记录每一个数据被访问的次数，即每一个数据都有其对应的计数器。那么NumCounters就是指计数器的数量，即数据的个数，进步一理解为key的数量（所有的key的数量，不仅仅是要缓存的数据的数量）。

## 2.2 MaxCost
设置了缓存可以使用的最大成本（以字节为单位）。这实际上决定了缓存的最大内存占用量。确保缓存不会占用超过指定量的内存。这对于防止应用程序因缓存过大而导致内存不足或被操作系统终止非常有用。
MaxCost是设置缓存的最大内存消耗。每个缓存项都有一个成本，成本较高的项在内存不足时更容易被淘汰。
默认情况下它使用Cost函数来计算每个缓存项的成本。可以设置每个缓存项的成本，会根据总成本进行自动调整。

当缓存达到 MaxCost 限制时，ristretto 会根据其内部算法（如 LRU - 最近最少使用）自动淘汰一些旧的或不常用的缓存项，以便为新项腾出空间。

虽然在基本用法中，每个缓存项的成本通常设为 1（即每个条目占用 1 字节），但你也可以为不同的缓存项分配不同的成本。例如，较大的数据对象可以分配更高的成本值，以便更精确地控制缓存的总大小。

例如，如果你设置了 MaxCost 为 1000，并且已经有一个成本为 100 的项和 90 个成本为 1 的项，那么再添加新的缓存项时，可能会导致缓存淘汰以腾出空间。

## 2.3 BufferItems
`Get 缓冲区` 当多个并发请求尝试获取相同的缓存键时，ristretto 会将这些请求缓冲起来，以避免重复的计算或数据获取操作。这有助于提高缓存的命中率和整体性能。
在大多数情况下，BufferItems 设置为 64 已经能够提供良好的性能。这意味着每个 Get 操作可以缓冲最多 64 个并发请求，从而减少锁竞争和提高吞吐量。
建议以 64 为单位逐步增加 BufferItems 的值。例如，从 64 增加到 128，再到 192，依此类推。
