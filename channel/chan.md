# 基本特性
* 类型安全： 可以传递任何类型的数据
* 缓冲： 可以是带缓冲或无缓冲的
* 同步： 提供同步机制，可以在数据发送和接受时同步 goroutines
* 关闭： 可以被关闭，一旦关闭就不能再发送数据

# 用途
* 同步： 协调多个 goroutines 的执行
* 通信： 在多个 goroutines 之间传递数据
* 并行： 收集并发执行的结果


# 读
当通道读写数据时，所在协程会阻塞并且调度控制权会转移到其他未阻塞的协程。

如果当前协程正在从一个没有任何值的通道中读取数据，那么当前协程会阻塞并且等待其他协程往此通道写入值。因此，读操作将被阻塞。

# 写

发送数据到一个通道，它将阻塞当前协程直到有其他协程从通道中读取数据，此时写操作将阻塞。


# 关闭通道

* 不能向一个关了的channel发信息
* 虽然关闭了通道，但是其实数据不仅在通道里面，数据还在缓冲区中的，我们依然可以读取到这个数据。


# 缓冲区
* 当缓冲区参数不是 0 的时候。协程将不会阻塞除非缓冲区被填满。
* 缓冲区满了，再往缓冲区发送数据只有等到有其他协程从缓冲区接收数据， 此时的发送协程是阻塞的。
* 读缓冲区的操作是渴望式读取，读操作开始它将读取缓冲区所有数据，直到缓冲区为空。

# 通道的长度和容量
* 和切片类似，一个缓冲通道也有长度和容量。 
* 通道的长度是其内部缓冲队列未读的数据量，而通道的容量是缓冲区可最大盛放的数据量。 我们可以使用 len 函数去计算通道的长度，使用 cap 函数去获得通道的容量。

# 单向通道
* 只读通道只允许读操作，只写通道只允许写操作。
* 使用单向通道可以 提高程序的类型安全性， 使得程序不容易出错。

``` go
roc := make(<-chan int) // 只读通道
soc := make(chan<- int) // 只写通道
```

通过函数的参数类型可以将 chan 从双向通道改成单向接收通道。
```go
func convertSingleChan(roc <-chan string) {
    fmt.Println("Hello " + <-roc ,"!")
}
```

# select
* select 语句和 switch 很像，不同点是用通道读写操作代替了布尔操作。通道将被阻塞，除非它有默认的 default 块。一旦某个 case 条件执行，它将不阻塞。
* 如果所有的 case 语句（通道操作）被阻塞，那么 select 语句将阻塞直到这些 case 条件的一个不阻塞（通道操作），case 块执行。
* 如果有多个 case 块（通道操作）都没有阻塞，那么运行时将随机选择一个不阻塞的 case 块立即执行。
* default case 块 是非阻塞的，不仅如此， default case 块可以使 select 语句永不阻塞，这意味着， 任何通道的 发送 和 接收 操作 (不管是缓冲或者非缓冲) 都不会阻塞当前线程。
* 空 select: select{} 没有 case 非阻塞语句，主线程将阻塞并可能会导致死锁。

# WaitGroup
* 是一个带着计数器的结构体，这个计数器可以追踪到有多少协程创建，有多少协程完成了其工作。当计数器为 0 的时候说明所有协程都完成了其工作。