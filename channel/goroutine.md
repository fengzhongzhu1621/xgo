# 1. 调度对象：进程和线程

时间片轮转：多个程序快速切换使用 CPU，这种切换策略被称为 调度。
Linux 进程和线程的上下文切换开销通常在 3-5 微秒之间。

调度器调度的是什么？

* 执行中的不同程序 (进程)
* 进程的子集，CPU 利用的基本单位 (线程)

然而，线程切换会带来一定的开销。

* 进程：

当 CPU 在多个程序之间切换时，如果不保存之前程序的状态（即上下文），直接切换到下一个程序，那么之前程序的一系列状态会丢失。为了解决这个问题，引入了进程的概念。进程为程序执行分配所需的资源，因此进程是程序运行的基本资源单位（也可以看作程序执行的实体）。例如，运行一个文本编辑器时，该进程会管理所有资源，如文本缓冲区的内存空间、文件操作资源等。

* 线程：

CPU 在多个进程之间切换时，由于需要进入内核模式并读取用户模式数据，切换开销较大。随着进程数量增加，CPU 调度会消耗大量资源。为了解决这一问题，引入了线程的概念。线程本身消耗的资源很少，它们共享进程内的资源。线程的调度开销比进程小得多。例如，在一个 Web 服务器应用中，可以使用多个线程同时处理不同的客户端请求，这些线程共享服务器进程的资源（如网络连接和内存缓存）。

* 线程：

协程拥有自己的寄存器上下文和栈。当协程被调度切换时，会保存当前的寄存器上下文和栈；当切换回来时，则恢复之前保存的上下文和栈。因此，协程可以保留上一次调用的状态（即所有局部状态的特定组合）。每次重新进入协程时，相当于返回到上次调用时的状态，即逻辑流程中上次退出的位置。

线程和进程的操作由系统接口触发，最终由系统执行；而协程的操作由用户程序自身执行。Goroutine 就是一种协程。

查看线程栈大小
```sh
ulimit -a
-s: stack size (kbytes)      8176
```

## 1.1 进程内存布局
```
高地址
+ - - - - - - - - - - - - - - - +
| Stack                         | ←- 栈，静态分配
| - - - - - - - - - - - - - - - | 
| Heap                          | ←- 堆，动态分配
| - - - - - - - - - - - - - - - | 
| Uninitialized Data            | ←- 未初始化数据
| - - - - - - - - - - - - - - - | 
| Initialized Data              | ←- 初始化数据
| - - - - - - - - - - - - - - - | 
| Code                          | ←- 代码（文本段）
+ - - - - - - - - - - - - - - - +
低地址
```

* 栈（Stack）：这部分内存用于静态内存分配，栈内存是一个连续的内存区域，通常从高地址向低地址增长。每次函数调用都会在栈上分配一个新的栈帧，函数返回时栈帧会被释放会随着函数的调用和返回而自动增大和缩小。。栈帧包含了函数调用的上下文信息，包括函数的参数、局部变量和返回地址。
    - 保存函数的局部变量；
    - 返回函数的返回值；
    - 向被调用函数传递参数；
    - 保存函数的返回地址，返回地址是指从被调用函数返回后调用者应该继续执行的指令地址
* 堆（Heap）：这是动态内存分配区域。当程序需要申请未预先定义的内存时，就会向堆申请空间。这里的内存可以在运行时分配和释放，为程序提供了处理数组、链表等动态数据结构所需的灵活性。动态分配：内存在运行时申请、释放。可变大小：分配的内存大小可以变化。基于指针的管理：使用指针访问和控制内存。堆内存由操作系统管理。当程序请求内存时，操作系统会从进程的堆内存段中分配内存。堆从低地址向高地址增长。
* 未初始化数据（BSS 段）：该段存放开发者已声明但并未初始化的全局变量和静态变量。程序启动时，操作系统会将这些变量初始化为零。
* 初始化数据：该区域包含开发者已初始化的全局变量和静态变量。程序一开始运行，这些变量就可以立即使用。
* 代码（文本段）：该段存储程序的可执行指令。通常这部分内存是只读的，以防止意外修改程序指令。

寄存器

AMD64 CPU中有3个与栈密切相关的寄存器：
* rsp寄存器 ，始终指向当前函数调用栈栈顶。
* rbp寄存器 ，一般用来指向当前函数栈帧的起始位置，即栈底。
* ip寄存器，保存着下一条将要执行的指令的内存地址。CPU在执行指令时，会根据IP寄存器的值从内存中获取指令从而执行，在大多数情况下，IP寄存器的值会按顺序递增，以指向下一条指令，这使得程序能够顺序执行。

# 2. 内核态和用户态
* ***内核态线程***：由操作系统管理和调度，CPU只负责处理内核态线程。
* ***用户态线程***：由用户程序管理，需绑定到内核态线程上执行，协程即为用户态线程的一种。


# 3. goroutine

用户级线程由运行时系统 (用户级库) 管理，其切换开销几乎与函数调用相同。内核对用户级线程一无所知，将其视为单线程进程。
协程是由 Go 运行时管理的轻量级用户空间线程,比传统的操作系统线程更高效, Go 并没有对协程数量设置严格限制, 在合适的条件下,你可以同时运行数千甚至数百万个协程, 实际限制主要取决于可用的系统资源,特别是内存, 因为每个协程启动时都有一个小的栈空间(约 2KB)。

* 在 Go 中，用户级线程被称为 goroutine。
* goroutine 是 Go 运行时管理的轻量级线程，逻辑上代表着执行线程。
* Goroutine的调度由Go语言的运行时（runtime）负责，而不是操作系统。Go运行时在用户态进行调度，避免了频繁的上下文切换带来的开销，使得调度更加高效。
* 在Go程序中，main函数本身也是一个Goroutine，称为主Goroutine。当主Goroutine结束时，所有其他Goroutine也会随之终止。因此，需要确保主Goroutine等待所有子Goroutine执行完毕。
* 线程是运行Goroutine的实体，而调度器的功能是将可运行的Goroutine分配到工作线程上。

# 4. 协程效率

## 4.1 内存限制

具有 2 个 CPU 核心和 100MB RAM 的云环境。每个协程初始约需 2KB 栈空间，100MB RAM 中预留 20MB 给 Go 运行时和系统开销,剩余约 80MB 用于协程 理论上限计算: 最大协程数 = 80MB / 0.002MB (2KB) = 40,000

### 4.1.1 栈扩容
当Goroutine运行时发现栈空间不够，比如递归太深、局部变量太多，Go就会触发栈扩容。
1. 先开辟一块更大的新栈空间（通常是原来的2倍）。
2. 把老栈上的数据迁移过去。
3. 更新指针，让程序继续运行。

### 4.1.2 栈缩容
缩容的策略和扩容相似，重新分配一块小一点的栈，再把数据挪过去。

* 函数调用结束，Goroutine 闲置。
* 或者某些GC阶段，检测到栈利用率太低。

## 4.2 CPU 限制
2 个 CPU 核心意味着 Go 运行时只能同时执行 2 个操作系统线程(如果 GOMAXPROCS 设为 2) Go 调度器在这些线程上处理协程,如果数千个协程运行 CPU 密集型任务,上下文切换会增加开销 对于双核实例,实际协程数量通常在 1,000 到 5,000 之间,具体取决于工作负载。

## 4.3 调度开销
Go 的运行时调度器可以高效地管理操作系统线程上的协程,但如果协程太多,可能会因调度而导致上下文切换和潜在的性能问题。

## 4.4 查看内存分配
```go
$ go build -o memory_allocation main.go
$ strace -f -e trace=mmap,munmap ./memory_allocation
```

# 5. 协作式的抢占式调度

在1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度

* 某些 Goroutine 可以⻓时间占用线程，造成其它 Goroutine 的饥饿
* 垃圾回收需要暂停整个程序(Stop-the-world，STW)，最⻓可能需要几分钟的时间，导致整个程序无法工作。

# 6. GMP

G 是 Goroutine 执行的实体，M 是 Goroutine 的承载者，P 是调度器。

## 6.1 P（Processor 协程调度器）
* P代表执行上下文（Processor）。P管理着可运行的Goroutine队列，并负责与M进行绑定。P的数量决定了可以并行执行的Goroutine的数量。Go运行时会根据系统的CPU核数设置P的数量。每个 P 可以运行一个 Goroutine。
* 包含了运行 goroutine 的资源。如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。
* P 维护一个 Goroutine 队列，存储需要由其执行的所有 Goroutine。例如，当创建多个 Goroutine 时，这些 Goroutine 会被添加到 P 的队列中等待调度。
* P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数; 逻辑处理器 P 的数量始终固定 (默认为当前进程可用的逻辑 CPU 数量)
* 所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS (可配置)个。P 的数量由 环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定，当 P 的数量 n 确定以后，运行时系统会根据这个数量创建 n 个 P。
* 在任何情况下，Go运行时并行执行(注意，不是并发)的 goroutines 数量是小于等于 P 的数量的，即可以同时运行的 Goroutine 数量。
* P 代表处理器，可以看作是在线程上运行的本地调度器。
* Go 运行时将首先根据机器的逻辑 CPU 数量 (或根据请求) 创建固定数量的逻辑处理器 P。
* 每个 Goroutine 都是由 Go 运行时调度器（Scheduler）进行调度的。调度器负责将 Goroutine 转换成线程上的执行上下文，并在多个线程之间分配 Goroutine 的执行。
* Go 调度器的调度策略是基于协作式调度的。 也就是说，调度器会在 Goroutine 主动让出执行权（例如在 I/O 操作、channel 操作、time.Sleep() 等操作中）时，将 CPU 的执行权转交给其他 Goroutine。这种调度策略可以保证 Goroutine 之间的调度是非常轻量级的。
* Goroutine 的调度是非确定性的，也就是说，Goroutine 之间的调度是不可预测的。这种调度策略可以保证 Goroutine 的执行具有随机性，可以充分利用多核 CPU 的性能。在实现上采用的是用户态调度，不需要进行内核态和用户态之间的切换，从而可以更快地切换和调度多个 Goroutine。相比之下，传统的线程需要占用更多的资源和时间，因此在多并发的情况下，Go 的 Goroutine 会更加高效。

抢占 P 的时机
* 系统调用 (syscall) 后：当 Goroutine 执行系统调用后，Goroutine 会让出 P，此时调度器可能会选择调度其他的 Goroutine 来运行。
* 垃圾回收 (GC) 阶段：当触发垃圾回收时，调度器会在合适时机抢占 Goroutine，确保 GC 可以进行。
* 计算密集型任务被长时间运行：从 Go 1.14 开始，调度器会定期检查长时间运行的 Goroutine，并进行抢占。Go 调度器在后台维护一个时间戳，记录 Goroutine 上次被调度的时间。调度器每隔一段时间会检查当前运行的 Goroutine，如果 Goroutine 占用了 CPU 超过一定时间，调度器就会标记这个 Goroutine 需要被抢占，然后调度其他的 Goroutine 来执行。

p 的状态
```go
const ( 
    // 表示P没有运行用户代码或者调度器 
    _Pidle = iota 
    // 被线程 M 持有，并且正在执行用户代码或者调度器
    _Prunning 
    // 没有执行用户代码，当前线程陷入系统调用
    _Psyscall
    // 被线程 M 持有，当前处理器由于垃圾回收 STW 被停止
    _Pgcstop 
    // 当前处理器已经不被使用
    _Pdead
)
```


## 6.2 G（Goroutine）
系统线程对goroutine的调度与内核对系统线程的调度原理是一样的，实质都是通过保存和修改CPU寄存器的值来达到切换线程/goroutine的目的。因此，为了实现对goroutine的调度，需要引入一个数据结构来保存CPU寄存器的值以及goroutine的其它一些状态信息，在go语言调度器源代码中，这个数据结构是一个名叫g的结构体，它保存了goroutine的所有信息，该结构体的每一个实例对象都代表了一个goroutine。调度器代码可以通过g对象来对goroutine进行调度。

* 当goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在g对象的成员变量之中
* 当goroutine被调度起来运行时，调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到CPU的寄存器

* Goroutine是Go语言中的协程，代表一个独立的执行单元。Goroutine比线程更加轻量级，启动一个Goroutine的开销非常小。Goroutine的调度由Go运行时在用户态进行。
* 每个 goroutine (G) 都将在分配给逻辑 CPU (P) 的操作系统线程 (M) 上运行。
* 每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 2GB，那么至多允许 2GB/2KB = 1M 个协程同时存在。
* 全局G队列：存放等待运行的G。当 P 的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过 work stealing 机制从其他P的本地队列偷取 G。
* P的本地G队列：存放不超过256个G。当新建协程时优先将G存放到本地队列，如果队列满了，会将本地队列的一半 G 和新创建的 G 打乱顺序，一起放入全局队列。
* G0：G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数, 每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间, 全局变量的 G0是 M0 的 G0。
* 新创建的协程优先保存在P的本地G队列，如果本地队列满了，会将P本地队列中的一半G打乱顺序移入全局队列。
* 唤醒：创建G时，当前运行的G会尝试唤醒其他PM组合执行。若唤醒的M绑定的P本地队列为空，M会尝试从全局队列获取G。
* 偷取(work stealing 机制)：如果P的本地队列和全局队列都为空，会从其他P偷取一半G到自己的本地队列执行。当本线程无可运行的 G 时，尝试从其他线程绑定 P 的队列中偷取 G，而不是销毁线程。
* 抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程。在Go中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死。
* 自旋线程会占用CPU时间，但创建销毁线程也消耗CPU时间。系统最多有GOMAXPROCS个自旋线程，其他线程在休眠M队列里。
* 系统调用：当G进行系统调用时进入内核态被阻塞，M会释放绑定的P，把P转移给其他空闲的M执行。当系统调用结束，GM会尝试获取一个空闲的P。
* 阻塞处理(hand off 机制)：当G因channel或network I/O阻塞时，不会阻塞M。超过10ms时，M会寻找其他可运行的G。
* 公平性：调度器每调度61次时，会尝试从全局队列中取出待运行的Goroutine来运行。如果没有找到，就去其他P偷一些Goroutine来执行。
* P 的数量由 GOMAXPROCS 设置，最多有 GOMAXPROCS 个线程分布在多个 CPU上 同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

* P 的加入，还带来了一个本地协程队列，跟前面提到的全局队列类似，也是用于存放G，想要获取等待运行的G，会优先从本地队列里拿，访问本地队列无需加锁。而全局协程队列依然是存在的，但是功能被弱化，不到万不得已是不会去全局队列里拿G的。
* GM模型里M想要运行G，直接去全局队列里拿就行了；GMP模型里，M想要运行G，就得先获取P，然后从 P 的本地队列获取 G。
* 新建 G 时，新G会优先加入到 P 的本地队列；如果本地队列满了，则会把本地队列中一半的 G 移动到全局队列。P 的本地队列为空时，就从全局队列里去取。
* P 的本地队列为空时，就从全局队列里去取。
* 如果全局队列为空时，M 会从其他 P 的本地队列偷（stealing）一半 G 放到自己 P 的本地队列。
* M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。

## 6.3 M（Machine）
表示 Machine（即操作系统线程）
* M代表操作系统的线程。每个 M 对应一个线程，Goroutine 运行在 M 上。M负责实际执行Go代码。一个M可以执行多个Goroutine，但同一时间只能执行一个Goroutine。M与操作系统的线程直接对应，Go运行时通过M来利用多核CPU的并行计算能力。
* 当一个 Goroutine 被启动以执行复杂计算时，该 Goroutine 会被分配到一个 M 上执行。M 是一个较大的结构，包含小对象内存缓存（mcache）、当前正在执行的 Goroutine、随机数生成器等信息。
* 当本线程因G进行系统调用等阻塞时，线程会释放绑定的P，把P转移给其他空闲的M执行。
* 线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。
* go 程序启动时，会设置 M 的最大数量，默认 10000，但是内核很难支持这么多的线程数。
* 当没有足够的 M 来关联 P 并运行其中的可运行的 G 时，比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。
* M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M。
* M0：启动程序后的第一个主线程，负责执行初始化操作和启动第一个Goroutine，此后与其他M一样。这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。


# 7. 基于信号的抢占式调度
* sysmon 也叫监控线程，变动的周期性检查
* Sysmon 操作系统线程，它会定期轮询网络，如果超过 10 毫秒没有轮询，则会将准备好的 G 添加到队列。

* 释放闲置超过 5 分钟的 span 物理内存
* 如果超过 2 分钟没有垃圾回收，强制执行
* 将⻓时间未处理的 netpoll 添加到全局队列
* 向⻓时间运行的 G 任务发出抢占调度(超过 10ms 的 g，会进行 retake)
* 收回因 syscall ⻓时间阻塞的 P

# 8. panic

可以使用recover函数来捕获Goroutine中的panic，并进行相应的处理，如果没有对相应的Goroutine 进行异常处理，会导致主线程 panic 。

# 9。 底层实现
go 关键字启动后编译器器会通过cmd/compile/internal/gc.state.stmt和cmd/compile/internal/gc.state.call 两个方法将该关键字转换成runtime.newproc函数调用。

启动一个新的 Goroutine 来执行任务时，会通过 runtime.newproc 初始化一个 g 来运行协程。

Goroutine 在 Go 运行时（runtime）系统中可以有以下 9 种状态
* Gidle：Goroutine 处于空闲状态，即没有被创建或者被回收；
* Grunnable：Goroutine 可以被调度器调度执行，但是还未被选中执行；
* Grunning：Goroutine 正在执行中，被赋予了M和P的资源；
* Gsyscall：Goroutine 发起了系统调用，进入系统调用阻塞状态；
* Gwaiting：Goroutine 被阻塞等待某个事件的发生，比如等待 I/O、等待锁、等待 channel 等；
* Gscan：GC正在扫描栈空间
* Gdead：没有正在执行的用户代码
* Gcopystack：栈正在被拷贝，没有正在执行的代码
* Gpreempted：Goroutine 被抢占，即在运行过程中被调度器中断。等待重新唤醒


Goroutine 的调度时机一般有以下几种情况
* 当前 Goroutine 主动让出执行权时，调度器会将 CPU 的执行权转交给其他 Goroutine。
* 当前 Goroutine 执行的时间超过了 Go 运行时所设置的阈值时，调度器会将当前 Goroutine 暂停，将 CPU 的执行权转交给其他 Goroutine。
* 当前 Goroutine 进行 I/O 操作、channel 操作或者其他系统调用时，调度器会将当前 Goroutine 暂停，将 CPU 的执行权转交给其他 Goroutine。
* 当前 Goroutine 被阻塞在同步原语（例如 sync.Mutex）时，调度器会将当前 Goroutine 暂停，将 CPU 的执行权转交给其他 Goroutine。


# 10. 内核线程绑定
默认goroutine不会绑定在一个内核线程上，它是调度器自由管理的。调度器可以非常高效地在多个线程上分配运行它们。
但可以通过runtime.LockOSThread()手动绑定，适用于需要线程一致性的场景，比如调用某些C库或GUI相关操作。

```go
func main() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    go func() {
    fmt.Println("这个协程可以在任何线程上执行")
    }()

    fmt.Println("我绑定在当前线程上了")
}

```
