sync.Pool 是 Go 语言标准库中提供的一个用于对象复用的工具

# 1. 特点

* **对象缓存**：使用 Get、Put 方法可以获取和归还sync.Pool中的数据，从而减轻内存分配与垃圾回收的压力

* **自动回收**：sync.Pool中的对象可能会被自动回收。即使将对象放入池中，也不能保证该对象会一直存在于池中。当内存紧张或者垃圾回收器运行时，sync.Pool中的对象可能会被回收，所以 sync.Pool 适用于存储那些临时使用、生命周期较短的对象

* **并发安全**：并发访问是安全的。多个 goroutine 可以同时从池中获取和放回对象，而不需要额外的同步机制。其大小仅受限于内存的大小。

* **状态不可靠**：由于sync.Pool中的对象可能会被自动回收，所以不能依赖池中对象的状态。在从池中获取对象后，应该根据具体的使用场景对对象进行初始化，以确保对象处于正确的状态

# 2. 原理
- 利用 GMP 的特性，为每个 P 创建了一个本地对象池 poolLocal，尽量减少并发冲突。
- 每个 poolLocal 都有一个 private 对象，优先存取 private 对象，可以避免进入复杂逻辑。
- 在 Get 和 Put 期间，利用 pin 锁定当前 P，防止 goroutine 被抢占，造成程序混乱。
- 在获取对象期间，利用对象窃取的机制，从其他 P 的本地对象池以及 victim 中获取对象。
- 充分利用 CPU Cache 特性，提升程序性能。

# 3. 适用场景

* **频繁创建和销毁对象的场景**
在处理大量并发请求的服务器中，可能需要频繁地创建和销毁一些临时的结构体来存储请求数据。使用sync.Pool可以复用这些结构体，减少内存分配和垃圾回收的开销。
需要频繁地创建和销毁一些临时的切片来存储中间结果的场景，使用sync.Pool可以提高程序的性能。

* **减少内存分配压力的场景**
在一些对内存分配比较敏感的场景中，如嵌入式系统或者资源受限的环境中，使用sync.Pool可以有效地减少内存分配的次数，从而降低内存占用。


# 4. 对象清理
Golang 对 sync.Pool 的清理逻辑非常简单粗暴。首先每个被使用的 sync.Pool，都会在初始化阶段被添加到全局变量 allPools []*Pool 对象中。Golang 的 runtime 将会在 每轮 GC 前，触发调用 poolCleanup 函数，清理 allPools。

sync.Pool 中的对象在 GC 时会被清空（除非被复用），通过 Put() 将对象放回池中，可以在两次 GC 之间复用对象，减少 GC 触发的频率和扫描的对象数量。
“只要能在两次 GC 之间复用一次，就达到了优化目的”，而 Put() 是实现这一目标的关键。

# 5. 注意
- sync.Pool 缓存的对象随时可能被无通知的清除，因此不能将 sync.Pool 用于存储持久对象的场景。

# 6. 方法
### 6.1 Get()
用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。

### 6.2 Put()
则是在对象使用完毕后，返回对象池。
Put() 会将对象优先存入当前 P 的私有空间，供后续 Get() 快速获取，避免跨 P 的锁竞争。
sync.Pool 的核心设计目标是通过复用临时对象来避免频繁的内存分配。如果不调用 Put()，对象不会被放回池中，导致每次 Get() 时都可能触发 New 函数创建新对象，从而失去复用价值。
