# map

## 初始化
1. 不初始化长度：如果你声明一个 map 但没有进行初始化，那么它就是 nil，你无法直接对它进行操作。必须先使用 make() 或者字面量进行初始化才能使用。否则会出现 panic 错误。
2. 初始化长度：通过 make() 函数来初始化 map 的容量，这样不仅避免了 nil 的问题，还能通过预设容量来提高性能，避免频繁的内存重分配。

## 并发行
map 遍历和删除操作无法同时进行，Go 标准库并没有为 map 提供专门的并发安全保障。
如果试图在遍历过程中修改 map，Go 运行时会检测到这种操作，并抛出一个 panic 来提醒开发者。
可以通过在遍历时先记录下待删除的键，然后在遍历结束后再执行删除。

## 底层结构
```go
// runtime/map.go
// A header for a Go map.
type hmap struct {
    count     int // 当前哈希表中键值对的数量
    flags     uint8
    B         uint8  // 当前哈希表持有的 buckets 数量, 因为哈希表中桶的数量都按2倍扩容,改字段存储对数，也就是 len(buckets) == 2^B
    noverflow uint16 // 溢出桶的大致数量
    hash0     uint32 // hash seed

    buckets    unsafe.Pointer // 存储 2^B 个桶的数组
    oldbuckets unsafe.Pointer // 扩容时用于保存之前 buckets 的字段
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

    extra *mapextra // optional fields
}

// mapextra 主要维护，当hmap中的buckets中有一些桶发生溢出，但有达不到扩容阈值时，存储溢出的桶
type mapextra struct {
    overflow    *[]*bmap
    oldoverflow *[]*bmap

    // nextOverflow holds a pointer to a free overflow bucket.
    nextOverflow *bmap
}
```

* count：表示哈希表中键值对的数量；
* B：这是以 2 为底的对数，用于确定桶（bucket）的数量。例如，当 B = 1 时，桶的数量为 2^1 = 2 个；当 B = 2 时，桶的数量为 2^2 = 4 个，以此类推；
* hash0：是计算键的哈希值时用到的一个因子；
* buckets：是一个指向桶数组的指针，每个桶用于存储键值对；map通过一个指向桶数组的指针来管理所有的桶。桶数组的大小通常是2的幂次方，以便于通过哈希值快速定位桶的位置。
* 桶（Bucket）：是map内部用于存储键值对的结构单元。每个桶可以存储多个键值对，具体容量在Go的不同版本中有所不同。例如，在Go 1.18及之后的版本中，每个桶通常可以存储8个键值对。每个键通过哈希函数计算出一个哈希值，然后通过取模或其他方式确定该键应当存储在哪个桶中。除了实际的键和值，桶中还存储了每个键的部分哈希值。这部分哈希值用于在进行键的比较时快速排除不可能相等的键，从而提高查找效率。
* overflow：当桶中装不下更多元素，且 key 又被 hash 到这个桶时，就会放到溢出桶，原桶的 overflow 字段指向溢出桶（链地址法）。当一个桶中的键值对数量超过其容量时，map会使用额外的桶来存储溢出的键值对。这些额外的桶通过链表或其他数据结构连接到主桶上，形成溢出链。当一个桶填满后，新的键值对会被存储到与该桶关联的溢出桶中。溢出桶通过指针链接到主桶，形成一个链式结构。这种设计允许map在不频繁扩容的情况下存储大量的键值对，但也可能导致在极端情况下链表过长，影响查找性能。


## 扩容
### 1. 原理
底层是哈希表，哈希冲突多了，性能就下降。为了避免这个，Go 会在合适的时候扩容。

Go 的 map 桶是固定 8 个键值对。

扩容的时候，桶的数量是直接翻倍的，这样能有效减少哈希冲突。但别以为扩容就是简单地多点桶，Go 还要重新把所有的键值对“搬家”，重新算一遍哈希分布，专业术语叫rehash。

* 双倍扩容：当map中的键值对数量超过当前桶数组容量的某个阈值（通常是6.5倍），map会触发扩容操作。当 Map 的负载超过一定阈值时会触发双倍扩容。负载的计算方式是元素个数（count）除以桶的数量（2^B），如果这个比值大于等于 6.5，则认为负载超了。例如，当 B = 2，桶有 2^2 = 4 个，如果元素个数 count 为 26（26/4 = 6.5），就会触发双倍扩容。
    - 增加桶的数量：新的桶数组大小通常是原来的两倍，即B值增加1。通过增加桶的数量，减少每个桶中键值对的平均数量，从而降低哈希冲突的概率，提升查找性能。
    - 重新哈希：现有的键值对被重新计算哈希值，并分配到新的桶数组中。这个过程称为“搬迁”（evacuation）。
    - 使用旧桶和新桶：在搬迁过程中，map会同时维护旧的桶数组和新的桶数组，直到所有键值对都被搬迁完毕。在多个GC周期内逐步完成搬迁过程。
* 等量扩容：当有大量的键被删除，导致溢出桶过多时，可能会触发等量扩容。这里的溢出桶是指当一个桶存满 8 个元素后，新的元素会存储到溢出桶中，溢出桶不占用桶的数量计数。当溢出桶的数量大于等于 2^B 时，可能触发等量扩容。但如果是由于哈希冲突导致溢出桶过多且负载超了，会优先触发双倍扩容。
等量扩容主要是对桶进行整理，去除空的位置。它会创建一个新的桶数组，然后遍历老的桶数组，将不为空的键值对重新放置到新的桶数组中，同时释放原来的溢出桶。由于哈希因子、B 值和哈希算法都没有变化，键值对在新桶中的位置计算方式与原来相同，只是去除了空的存储位置，使键值对更加紧凑，提高后续操作的效率。

### 2. 避免扩容
#### 2.1 预估容量，提前分配
```go
m := make(map[string]int, 1000) // 提前估算
```

#### 2.2 别频繁删除再插入
频繁删插操作，可能导致溢出桶堆积，容易触发扩容。能用 sync.Map 的场景，别硬用 map。
