# sync.Once

## 简介

一个函数只运行一次，无论它被调用多少次或有多少个 goroutine 同时访问，
非常适合初始化单例资源，这些资源在应用程序生命周期中只应该发生一次。

延迟某些操作直到首次需要（懒加载），这可以提高运行时性能并减少初始内存使用。例如，如果只有在首次访问时才创建大型查找表，那么创建表的内存和处理时间将被节省。

大多数情况下，它比使用 init() 更适合初始化（外部）资源。

## 缺点
如果传递给 Once.Do 的函数在运行时发生 panic，sync.Once 仍然将其视为"任务完成"。这意味着将来对 Do(f) 的调用不会再次运行该函数。尤其是当试图捕获 panic 并在之后处理错误时，没有重试机会。

从 Go 1.21 开始，我们得到了 OnceFunc、OnceValue 和 OnceValues。


# sync.OnceFunc

是 sync.Once 的便捷包装器，接受函数 f 并将其包装在另一个函数中，可以多次调用该函数，但 f 本身只运行一次

如果 f() 在第一次执行时发生 panic，每次后续调用 wrapper() 都会以相同的错误 panic。

缺点是无法捕获错误。

# sync.OnceValue
会记住 f 的第一次执行结果，并在后续调用中直接返回缓存的结果。返回单个值。

# sync.OnceValues
会记住 f 的第一次执行结果，并在后续调用中直接返回缓存的结果。返回多个值，包含错误。

无论是 panic 还是错误，结果和失败状态都会被缓存。
