# 简介
用于防止缓存击穿攻击。它可以确保在高并发情况下，对于同一缓存键的多次访问只会触发一次实际的数据加载操作。而其他并发请求会共享同一个计算结果。
通过一个共享的锁机制来保证，多个 goroutine 在请求相同资源时，只有第一个请求会实际执行计算或者请求，其他请求会等待第一个请求完成后返回相同的结果。

singleflight 只用在并发场景下，同时有多个重复的请求，才能够合并请求。而当请求结束，就会执行 delete(g.m, key) 删除 key，下一次请求过来 fn 依然被重新执行。

# 使用场景

## 解决缓存穿透
如果某个请求数据不存在于缓存中，就会从数据库或者外部服务中获取。会导致重复的数据库操作，
使用 singleflight 可以确保只有一个请求去访问数据库，其他请求可以等待并复用相同的数据。

## 避免重复计算
多个 goroutine 可能同时请求一个计算结果，通过 singleflight 保证只有一个请求进行计算，其他请求复用结果。
例如在递归计算场景可以复用计算结果，减少CPU的消耗。


# 函数

```golang
Do(key string, fn func() (interface{}, error))
```
* 如果 key 对应的请求尚未执行过（即没有 goroutine 在处理），那么会调用 fn 来计算并返回结果。
* 如果已经有 goroutine 正在处理这个 key，其他的 goroutine 会等待这个 goroutine 完成计算，等待结果并返回。
