# 限流
* 防止系统过载：确保系统在高负载情况下仍能保持稳定运行。
* 保证服务质量：为所有用户提供公平的服务，避免某些用户占用过多资源。

# 固定窗口计数器算法
固定窗口计数器算法通过对请求进行计数，限制在固定时间窗口内的请求数。每个窗口开始时计数器被重置，遍历时间限制内的请求次数。

# 滑动窗口计数器算法
动窗口的思想是将固定窗口拆成更多个小窗口，随着时间的推移，窗口不断的滑动，统计也在不断的变化。窗口拆分的越多，滑动就会越平滑，统计就会越精确，所消耗的资源就会越多。滑动窗口如果只拆为1个窗口，就退化为固定窗口。

```go
go get github.com/RussellLuo/slidingwindow
```

方法
* Allow()：判断是否允许一个新的请求。
* AllowN(now time.Time, n int64)：判断是否允许  n  个新的请求。
* SetLimit(newLimit int64)：设置新的请求限制

窗口，包括添加计数、获取计数、重置窗口等
* LocalWindow：本地窗口，适用于单机应用。
* SyncWindow：同步窗口，适用于分布式环境。

Synchronizer 负责在多个实例之间同步窗口的状态。
* BlockingSynchronizer：阻塞式同步器。
* NonblockingSynchronizer：非阻塞式同步器。

# 漏桶算法
漏桶算法通过一个固定速率的漏桶完成请求，任何超出桶容量的请求将被拒绝。请求以固定速率从桶中出桶。

* 优点：能够平滑处理流量，避免突发请求。
* 缺点：如果桶满了，则请求会被立即拒绝。

漏桶算法的特点是流入速度不确定，但是流出速度是确定的，漏桶可以很平滑，均衡的处理请求，但是无法应对短暂的突发流量。

漏桶算法适用于需要严格控制处理速率的场景，如API限流、消息队列消费速率控制等。

# 令牌桶算法
令牌桶算法的思想是不断的生成令牌放到一个桶中，请求到来时到桶中申请令牌，申请得到就执行，申请不到就拒绝。如果桶中的令牌满了，新生成的令牌也会丢弃。

与漏桶不同的是，令牌桶是流入速度确定（生成令牌的速度），流出速度不确定，所以它不像漏桶一样可以均衡的处理请求，
但是由于有令牌桶这个缓冲，一旦有突增的流量，令牌桶里已有的令牌可以短暂的应对突发流量。

由于流出速度是不限制的，此时桶中已有的令牌都可以被申请到，请求一下子就会到我们的服务，给系统带来一定的压力，所以桶的大小需要合适，不宜过大。

令牌桶算法可以说是对漏桶算法的改进。漏桶算法能限制请求的速率。而令牌桶算法在限制请求速率的同时还允许一定程度的突发调用。

# 基于用户的限流

# 动态限流

# 客户端限流

# golang.org/x/time/rate
是 Go 语言官方提供的一个限流库，用于在程序中限制特定操作的速率。该库使用了令牌桶算法，可以通过设置一个速率限制r（即每秒可以执行的操作数）和一个容量b（即令牌桶的大小）来控制操作的速率。

* Allow(l Limit) bool
该方法用于检查是否可以处理一个事件（或一个令牌），返回一个布尔值。如果令牌桶中有足够的令牌以满足要求，则返回true；否则返回false。
* AllowN(l Limit, n int) bool
该方法与Allow方法类似，但可以同时处理n个事件（或令牌），返回一个布尔值。如果令牌桶中有足够的令牌以满足要求，则返回true；否则返回false。

* Burst() int
该方法返回令牌桶的容量，即最大的令牌数量。

* Limit() Limit
该方法返回令牌桶的限制速率。

* Reserve(l Limit) *Reservation
该方法返回一个Reservation对象。Reservation对象表示一个持续时间段，表示一个事件（或令牌）的预订。使用该对象可以等待预订的时间段，然后再处理事件（或令牌）。

* ReserveN(l Limit, n int) *Reservation
该方法与Reserve方法类似，但可以同时预订n个事件（或令牌）。返回一个Reservation对象。(具体不再重复，代码可参考Reserve)

* SetBurst(b int)
用于动态设置令牌桶的容量，即最大的令牌数量。

* SetBurstAt(t time.Time, b int)
用于在给定的时间设置令牌桶的容量。

* SetLimit(l Limit)
动态设置令牌桶的限制速率。

* SetLimitAt(t time.Time, l Limit)
用于在给定的时间设置令牌桶的限制速率。

* Tokens() float64
返回令牌桶中当前的令牌数量。

* TokensAt(t time.Time) float64
返回在给定的时间令牌桶中的令牌数量。

* Wait(t time.Time) bool
等待直到指定的时间t再处理事件（或令牌）。返回一个布尔值，如果在指定的时间段内有足够的令牌，则返回true；否则返回false。

* WaitN(t time.Time, n int) bool
与Wait方法类似，但可以同时等待n个事件（或令牌）。返回一个布尔值，如果在指定的时间段内有足够的令牌，则返回true；否则返回false。
